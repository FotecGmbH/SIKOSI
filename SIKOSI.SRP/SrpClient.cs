// (C) 2020 FOTEC Forschungs- und Technologietransfer GmbH
// Das Forschungsunternehmen der Fachhochschule Wiener Neustadt
// 
// Kontakt biss@fotec.at / www.fotec.at
// 
// Erstversion vom 08.07.2020 10:21
// Entwickler      Gregor Faiman
// Projekt         SIKOSI
namespace SRP_SDK
{
    using SecurityDriven.Inferno;
    using System;
    using System.Linq;
    using System.Numerics;
    using System.Text;

    /// <summary>
    /// Represents the actual SRP client, that handles the SRP protocol transactions.
    /// </summary>
    public class SrpClient
    {
        /// <summary>
        /// Backing field of the <see cref="ClientPrivateValue"/> Property.
        /// </summary>
        private BigInteger clientPrivateValue;

        /// <summary>
        /// Backing field of the <see cref="ClientPublicValue"/> Property.
        /// </summary>
        private BigInteger clientPublicValue;

        /// <summary>
        /// Backing field of the <see cref="ServerPublicValue"/> Property.
        /// </summary>
        private BigInteger serverPublicValue;

        /// <summary>
        /// Backing field of the <see cref="SrpGroup"/> Property.
        /// </summary>
        private SRPGroup srpGroup;

        /// <summary>
        /// Initializes a new instance of the <see cref="SrpClient"/> class.
        /// Note: The generator and the value N are part of a SRP group, prematurely agreed upon by server and client.
        /// More information: https://tools.ietf.org/html/rfc5054#appendix-A
        /// </summary>
        /// <param name="hash">The password hash.</param>
        /// <param name="generator">The generator as defined by RFC5054.</param>
        /// <param name="N">A 128 byte prime number as defined by RFC5054.</param>
        /// <exception cref="ArgumentNullException">
        /// Is thrown if SRP group is null.
        /// </exception>
        public SrpClient(SRPGroup srpGroup)
        {
            this.SrpGroup = srpGroup;
        }

        /// <summary>
        /// Gets the SRP group.
        /// </summary>
        /// <value>The srp group.</value>
        /// <exception cref="ArgumentNullException">
        /// Is thrown if you attempt to set null.
        /// </exception>
        public SRPGroup SrpGroup
        {
            get
            {
                return this.srpGroup;
            }

            private set
            {
                this.srpGroup = value ?? throw new ArgumentNullException(nameof(value), "Srp group must not be null");
            }
        }

        /// <summary>
        /// Gets or sets the private client value a, which is part of the SRP protocol and 
        /// generated during Login. This value is kept secret and never shared with the server.
        /// </summary>
        /// <value>The private client value a.</value>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Is thrown if you attempt to set a negative value.
        /// </exception>
        public BigInteger ClientPrivateValue
        {
            get
            {
                return this.clientPrivateValue;
            }

            set
            {
                if (value < 0)
                    throw new ArgumentOutOfRangeException(nameof(value), "Value must not be negative.");

                this.clientPrivateValue = value;
            }
        }

        /// <summary>
        /// Gets or sets the public client value A, which is part of the SRP protocol
        /// and generated during login. This value is also sent over to the server.
        /// </summary>
        /// <value>The client public value A.</value>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Is thrown if you attempt to set a negative value.
        /// </exception>
        public BigInteger ClientPublicValue
        {
            get
            {
                return this.clientPublicValue;
            }

            set
            {
                if (value < 0)
                    throw new ArgumentOutOfRangeException(nameof(value), "Value must not be negative.");

                this.clientPublicValue = value;
            }
        }

        /// <summary>
        /// Gets or sets the public server value B, which is part of the SRP protocol.
        /// This value is generated by the server during Login and sent to the client.
        /// </summary>
        /// <value>The server public value B.</value>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Is thrown if you attempt to set a negative value.
        /// </exception>
        public BigInteger ServerPublicValue
        {
            get
            {
                return this.serverPublicValue;
            }

            set
            {
                if (value < 0)
                    throw new ArgumentOutOfRangeException(nameof(value), "Value must not be negative.");

                this.serverPublicValue = value;
            }
        }

        /// <summary>
        /// Generates the verifier that is stored in the servers database instead of the users password.
        /// </summary>
        /// <param name="username">The user name.</param>
        /// <param name="password">The users password.</param>
        /// <param name="salt">The users salt.</param>
        /// <returns>The generated verifier.</returns>
        /// <exception cref="ArgumentNullException">
        /// Is thrown if either of the arguments are null.
        /// </exception>
        public BigInteger GenerateVerifier(string username, string password, byte[] salt)
        {
            if(username == null)
                throw new ArgumentNullException(nameof(username), "User name must not be null");

            if (password == null)
                throw new ArgumentNullException(nameof(password), "Password must not be null");

            if (salt == null)
                throw new ArgumentNullException(nameof(salt), "Salt must not be null");

            var key = this.GeneratePrivateKey(username, password, salt);
            var verifier = BigInteger.ModPow(this.SrpGroup.Generator, key, this.SrpGroup.N);

            return verifier;
        }

        /// <summary>
        /// Generates the clients private key that is required for calculating the client verifier.
        /// </summary>
        /// <param name="username">Clients username.</param>
        /// <param name="password">Clients password.</param>
        /// <param name="salt">client salt.</param>
        /// <returns>The generated private key.</returns>
        /// <exception cref="ArgumentNullException">
        /// Is thrown if username, password or salt are null.
        /// </exception>
        private BigInteger GeneratePrivateKey(string username, string password, byte[] salt)
        {
            if (username == null)
                throw new ArgumentNullException(nameof(username), "User name must not be null");

            if (password == null)
                throw new ArgumentNullException(nameof(password), "Password must not be null");

            if (salt == null)
                throw new ArgumentNullException(nameof(salt), "Salt must not be null");

            byte[] key;

            using (var hmac = SuiteB.HmacFactory())
            {
                key = hmac.ComputeHash(salt.Concat(hmac.ComputeHash(Encoding.UTF8.GetBytes(username + ":" + password))).ToArray());
            }

            return key.Concat(new byte[1]).ToArray().ToBigInteger();
        }

        /// <summary>
        /// Generates the client values and storing them in memory for further use.
        /// Client public value A will be sent over to the server.
        /// Client private value a will be kept secret and not be sent to the server.
        /// </summary>
        /// <returns>The generated value "A"</returns>
        public BigInteger GenerateClientValues()
        {
            this.clientPrivateValue = ExtensionsAndHelpers.GenerateEphemeralPrivateValue(this.SrpGroup);
            this.clientPublicValue = BigInteger.ModPow(this.SrpGroup.Generator, this.clientPrivateValue, this.SrpGroup.N);

            return this.clientPublicValue;
        }

        /// <summary>
        /// Computes the client session key.
        /// </summary>
        /// <param name="userName">The clients username.</param>
        /// <param name="password">The clients password.</param>
        /// <param name="salt">The client salt.</param>
        /// <param name="serverPublicValue">The server public value B, that was generated and sent to the client by the server as part of the Login process.</param>
        /// <returns>The generated session key.</returns>
        /// <exception cref="ArgumentNullException">
        /// Is thrown if user name, password or salt are null.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Is thrown if B is negative.
        /// </exception>
        public BigInteger ComputeSessionKey(string userName, string password, byte[] salt, BigInteger serverPublicValue)
        {
            if (userName == null)
                throw new ArgumentNullException(nameof(userName), "User name must not be null");

            if (password == null)
                throw new ArgumentNullException(nameof(password), "Password must not be null");

            if (salt == null)
                throw new ArgumentNullException(nameof(salt), "Salt must not be null");

            if (serverPublicValue < 0)
                throw new ArgumentOutOfRangeException(nameof(serverPublicValue), "Value B must not be negative.");

            BigInteger u;
            BigInteger key;
            BigInteger k;

            using (var hmac = SuiteB.HmacFactory())
            {
                u = ExtensionsAndHelpers.ComputeU(hmac, this.clientPublicValue, serverPublicValue);
                key = GeneratePrivateKey(userName, password, salt);
                k = ExtensionsAndHelpers.ComputeK(this.SrpGroup, hmac);
            }

            var exponent = clientPrivateValue + u * key;

            var value = ExtensionsAndHelpers.Mod(serverPublicValue - (BigInteger.ModPow(this.SrpGroup.Generator, key, this.SrpGroup.N) * k % this.SrpGroup.N), this.SrpGroup.N);

            return BigInteger.ModPow(value, exponent, this.SrpGroup.N);
        }

        /// <summary>
        /// Computes the client proof. Use this proof to verify at the server that the client calculated the same sesion key
        /// as the server.
        /// </summary>
        /// <param name="sessionKey">The calculated session key by the client.</param>
        /// <returns>The client proof.</returns>
        /// <exception cref="ArgumentNullException">
        /// Is thrown if the session key is null.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// Is thrown if this method is called while the <see cref="ServerPublicValue"/> Property has not been set and therefore is null.
        /// If this exception is thrown, ensure that the server calculates its public and private values, and sends the public value to the client.
        /// </exception>
        public byte[] ComputeProof(byte[] sessionKey)
        {
            if (this.ServerPublicValue == null)
                throw new InvalidOperationException("Can not compute proof because public server value is missing.");

            if (sessionKey == null)
                throw new ArgumentNullException(nameof(sessionKey), "session key must not be null.");

            byte[] clientProof;
            int padLength = this.SrpGroup.N.ToByteArray().Length;

            clientProof = this.GenerateClientProof(sessionKey, this.ServerPublicValue.ToByteArray(), padLength);

            return clientProof;
        }

        /// <summary>
        /// Generates the expected server proof, using the calculated session key and client proof.
        /// Use this methods return value to validate the proof that was sent to the user by the server.
        /// If both proofs match, the session keys could be verified.
        /// </summary>
        /// <param name="clientProof">The calculated client proof.</param>
        /// <param name="sessionKey">The session key as calculated by the client.</param>
        /// <param name="padLength">The pad length.</param>
        /// <returns>The expected server proof.</returns>
        /// <exception cref="ArgumentNullException">
        /// Thrown if either of the parameters are null.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Thrown if pad length is negative.
        /// </exception>
        public byte[] GenerateExpectedServerProof(byte[] clientProof, byte[] sessionKey, int padLength)
        {
            if (sessionKey == null)
                throw new ArgumentNullException(nameof(sessionKey), "Session key must not be null.");

            if (clientProof == null)
                throw new ArgumentNullException(nameof(clientProof), "Server value must not be null.");

            if (padLength < 0)
                throw new ArgumentOutOfRangeException(nameof(padLength), "Pad length must not be negative.");

            using (var hmac = SuiteB.HmacFactory())
            {
                return hmac.ComputeHash((ExtensionsAndHelpers.PadBytes(this.clientPublicValue.ToByteArray(), padLength))
                   .Concat(ExtensionsAndHelpers.PadBytes(clientProof, padLength))
                   .Concat(ExtensionsAndHelpers.PadBytes(sessionKey, padLength))
                   .ToArray());
            }
        }

        /// <summary>
        /// Generates the client portion of the session key proof.
        /// </summary>
        /// <param name="sessionKey">The sessioni key as calculated by the client.</param>
        /// <param name="serverPublicValue">The servers public value B.</param>
        /// <param name="padLength">The pad length.</param>
        /// <returns>The generated client portion of the proof.</returns>
        /// <exception cref="ArgumentNullException">
        /// Is thrown if session key is null.
        /// Is thrown if server public value is null.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Is thrown if pad length is negative.
        /// </exception>
        private byte[] GenerateClientProof(byte[] sessionKey, byte[] serverPublicValue, int padLength)
        {
            if (sessionKey == null)
                throw new ArgumentNullException(nameof(sessionKey), "Session key must not be null.");

            if (serverPublicValue == null)
                throw new ArgumentNullException(nameof(serverPublicValue), "Server value must not be null.");

            if (padLength < 0)
                throw new ArgumentOutOfRangeException(nameof(padLength), "Pad length must not be negative.");

            using (var hmac = SuiteB.HmacFactory())
            {
                 return hmac.ComputeHash((ExtensionsAndHelpers.PadBytes(this.clientPublicValue.ToByteArray(), padLength))
                    .Concat(ExtensionsAndHelpers.PadBytes(serverPublicValue, padLength))
                    .Concat(ExtensionsAndHelpers.PadBytes(sessionKey, padLength))
                    .ToArray());
            }
        }
    }
}
